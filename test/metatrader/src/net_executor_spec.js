// Generated by CoffeeScript 1.9.0
(function() {
  var assert, klass, net, should, sinon;

  net = require('net');

  assert = require('chai').assert;

  sinon = require('sinon');

  should = require('chai').should();

  klass = require('../../../lib/metatrader').NetExecutor;

  describe('NetExecutor', function() {
    var host, object, port;
    object = void 0;
    host = sinon.spy();
    port = sinon.spy();
    before(function() {
      return object = new klass(host, port);
    });
    describe('#constructor', function() {
      it('exists method', function() {
        return object.constructor.should.be.a('function');
      });
      it('set this.host is success', function() {
        return assert.equal(object.host, host);
      });
      return it('set this.port is success', function() {
        return assert.equal(object.port, port);
      });
    });
    describe('#execute', function() {
      var callback, connection, error, request, stopReadCallback;
      request = sinon.spy();
      stopReadCallback = sinon.spy();
      callback = sinon.spy();
      error = sinon.spy();
      connection = {
        setTimeout: sinon.spy(),
        on: sinon.spy()
      };
      before(function() {
        sinon.stub(net, 'createConnection', function() {
          return connection;
        });
        sinon.stub(object.createConnectionCallback, 'bind', function() {
          return object.createConnectionCallback;
        });
        sinon.stub(object.setTimeoutCallback, 'bind', function() {
          return object.setTimeoutCallback;
        });
        sinon.stub(object.onCloseCallback, 'bind', function() {
          return object.onCloseCallback;
        });
        sinon.stub(object.onErrorCallback, 'bind', function() {
          return object.onErrorCallback;
        });
        sinon.stub(object.readConnectionCallback, 'bind', function() {
          return object.readConnectionCallback;
        });
        return object.execute(request, stopReadCallback, callback, error);
      });
      it('exists method', function() {
        return object.execute.should.be.a('function');
      });
      it('set this.request is success', function() {
        return assert.equal(object.request, request);
      });
      it('set this.stop_read_callback is success', function() {
        return assert.equal(object.stop_read_callback, stopReadCallback);
      });
      it('set this.callback is success', function() {
        return assert.equal(object.callback, callback);
      });
      it('set this.error is success', function() {
        return assert.equal(object.error, error);
      });
      it('called net.createConnection with port, host and callback', function() {
        return assert.equal(net.createConnection.calledWith(port, host, object.createConnectionCallback), true);
      });
      it('called connection.setTimeout with timeout and callback', function() {
        return assert.equal(connection.setTimeout.calledWith(5000, object.setTimeoutCallback), true);
      });
      it('called connection.on with close and callback', function() {
        return assert.equal(connection.on.calledWith('close', object.onCloseCallback), true);
      });
      it('called connection.on with error and callback', function() {
        return assert.equal(connection.on.calledWith('error', object.onErrorCallback), true);
      });
      return it('called connection.on with data and callback', function() {
        return assert.equal(connection.on.calledWith('data', object.readConnectionCallback), true);
      });
    });
    describe('#buildRequest', function() {
      it('exists method', function() {
        return object.buildRequest.should.be.a('function');
      });
      return it('returns is valid', function() {
        return assert.equal(object.buildRequest('request'), "Wrequest\nQUIT\n");
      });
    });
    describe('#closeConnection', function() {
      var connection, result;
      result = sinon.spy();
      connection = {
        destroy: sinon.stub().returns(result)
      };
      before(function() {
        object.connection = connection;
        return object.closeConnection();
      });
      it('exists method', function() {
        return object.closeConnection.should.be.a('function');
      });
      it('returns is valid', function() {
        return assert.equal(object.closeConnection(), result);
      });
      return it('called connection.destroy', function() {
        return assert.equal(connection.destroy.called, true);
      });
    });
    describe('#createConnectionCallback', function() {
      var buildRequest, connection, request, result;
      request = sinon.spy();
      buildRequest = sinon.spy();
      result = sinon.spy();
      connection = {
        write: sinon.stub().returns(result)
      };
      before(function() {
        sinon.stub(object, 'buildRequest', function() {
          return buildRequest;
        });
        object.connection = connection;
        object.request = request;
        return object.createConnectionCallback();
      });
      it('exists method', function() {
        return object.createConnectionCallback.should.be.a('function');
      });
      it('returns is valid', function() {
        return assert.equal(object.createConnectionCallback(), result);
      });
      it('called this.buildRequest with request', function() {
        return assert.equal(object.buildRequest.calledWith(request), true);
      });
      return it('called connection.write with buildRequest', function() {
        return assert.equal(connection.write.calledWith(buildRequest), true);
      });
    });
    describe('#setTimeoutCallback', function() {
      before(function() {
        object.error = sinon.spy();
        return object.setTimeoutCallback();
      });
      it('exists method', function() {
        return object.setTimeoutCallback.should.be.a('function');
      });
      return it('called this.error with error', function() {
        return assert.equal(object.error.calledWith('Connection timeout!'), true);
      });
    });
    describe('#onCloseCallback', function() {
      var buffer;
      buffer = sinon.spy();
      it('exists method', function() {
        return object.onCloseCallback.should.be.a('function');
      });
      describe('if this.stop_read_callback returns false', function() {
        before(function() {
          object.buffer = buffer;
          object.error = sinon.stub();
          object.stop_read_callback = sinon.stub().returns(false);
          return object.onCloseCallback();
        });
        it('called this.stop_read_callback with buffer', function() {
          return assert.equal(object.stop_read_callback.calledWith(buffer), true);
        });
        return it('called this.error with error', function() {
          return assert.equal(object.error.calledWith('Connection timeout!'), true);
        });
      });
      return describe('if this.stop_read_callback returns true', function() {
        before(function() {
          object.buffer = buffer;
          object.error = sinon.stub();
          object.stop_read_callback = sinon.stub().returns(true);
          return object.onCloseCallback();
        });
        it('called this.stop_read_callback with buffer', function() {
          return assert.equal(object.stop_read_callback.calledWith(buffer), true);
        });
        return it('not called this.error', function() {
          return assert.equal(object.error.called, false);
        });
      });
    });
    describe('#onErrorCallback', function() {
      var error;
      error = sinon.spy();
      before(function() {
        object.error = sinon.stub();
        return object.onErrorCallback(error);
      });
      it('exists method', function() {
        return object.onErrorCallback.should.be.a('function');
      });
      return it('called this.error with error', function() {
        return assert.equal(object.error.calledWith(error), true);
      });
    });
    return describe('#readConnectionCallback', function() {
      var buffer, data, new_buffer;
      data = sinon.spy();
      buffer = sinon.spy();
      new_buffer = sinon.spy();
      before(function() {
        object.buffer = buffer;
        sinon.stub(Buffer, 'concat', function() {
          return new_buffer;
        });
        object.stop_read_callback = sinon.stub();
        object.callback = sinon.stub();
        return object.readConnectionCallback(data);
      });
      it('exists method', function() {
        return object.readConnectionCallback.should.be.a('function');
      });
      it('called Buffer.concat with [buffer, data]', function() {
        return assert.equal(Buffer.concat.calledWith([buffer, data]), true);
      });
      it('called this.stop_read_callback with new_buffer', function() {
        return assert.equal(object.stop_read_callback.calledWith(new_buffer), true);
      });
      describe('if this.stop_read_callback returns true', function() {
        before(function() {
          object.closeConnection = sinon.stub();
          object.stop_read_callback = sinon.stub().returns(true);
          object.callback = sinon.stub();
          return object.readConnectionCallback(data);
        });
        it('called this.closeConnection', function() {
          return assert.equal(object.closeConnection.called, true);
        });
        return it('called this.callback with new_buffer', function() {
          return assert.equal(object.callback.calledWith(new_buffer), true);
        });
      });
      describe('if this.stop_read_callback returns false', function() {
        before(function() {
          object.closeConnection = sinon.stub();
          object.stop_read_callback = sinon.stub().returns(false);
          object.callback = sinon.stub();
          return object.readConnectionCallback(data);
        });
        it('not called this.closeConnection', function() {
          return assert.equal(object.closeConnection.called, false);
        });
        return it('not called this.callback with new_buffer', function() {
          return assert.equal(object.callback.called, false);
        });
      });
      return after(function() {
        return Buffer.concat.restore();
      });
    });
  });

}).call(this);
