// Generated by CoffeeScript 1.9.0
(function() {
  var assert, klass, should, sinon;

  assert = require('chai').assert;

  sinon = require('sinon');

  should = require('chai').should();

  klass = require('../../../lib/metatrader').QuotesCommand;

  describe('QuotesCommand', function() {
    var object, symbols;
    object = void 0;
    symbols = [1, 2, 3];
    before(function() {
      return object = new klass(symbols);
    });
    describe('#constructor', function() {
      it('exists method', function() {
        return object.constructor.should.be.a('function');
      });
      return it('set this.symbols is success', function() {
        return assert.equal(object.symbols, symbols);
      });
    });
    describe('#generateRequest', function() {
      it('exists method', function() {
        return object.generateRequest.should.be.a('function');
      });
      return it('returns is valid', function() {
        return assert.equal(object.generateRequest(), 'QUOTES-1,2,3,');
      });
    });
    describe('#stopReadCallback', function() {
      var empty_buffer, not_valid_buffer01, not_valid_buffer02, not_valid_buffer03, valid_buffer;
      valid_buffer = "2014.01.01 00:00:00";
      not_valid_buffer01 = "2014.01.0100:00:00";
      not_valid_buffer02 = " 2014.01.01 00:00:00";
      not_valid_buffer03 = "2014.01.01 00:00:00 ";
      empty_buffer = "";
      it('returns true when buffer valid', function() {
        return assert.equal(object.stopReadCallback(valid_buffer), true);
      });
      it('returns false when buffer not valid', function() {
        assert.equal(object.stopReadCallback(not_valid_buffer01), false);
        assert.equal(object.stopReadCallback(not_valid_buffer02), false);
        return assert.equal(object.stopReadCallback(not_valid_buffer03), false);
      });
      return it('returns false when buffer is empty', function() {
        return assert.equal(object.stopReadCallback(empty_buffer), false);
      });
    });
    return describe('#processResponse', function() {
      it('exists method', function() {
        return object.processResponse.should.be.a('function');
      });
      return it('returns is valid', function() {
        var response, result;
        response = "direction01 symbol01 bid01 ask01 date01 time01\n" + "direction02 symbol02 bid02 ask02 date02 time02\n" + "2014.01.01 00:00:00";
        result = [
          {
            direction: 'direction01',
            symbol: 'symbol01',
            bid: 'bid01',
            ask: 'ask01',
            date: 'date01',
            time: 'time01'
          }, {
            direction: 'direction02',
            symbol: 'symbol02',
            bid: 'bid02',
            ask: 'ask02',
            date: 'date02',
            time: 'time02'
          }
        ];
        return assert.deepEqual(object.processResponse(response), result);
      });
    });
  });

}).call(this);
