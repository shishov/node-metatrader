// Generated by CoffeeScript 1.9.0
(function() {
  var assert, http, klass, should, sinon;

  http = require('http');

  assert = require('chai').assert;

  sinon = require('sinon');

  should = require('chai').should();

  klass = require('../../../lib/metatrader').HttpExecutor;

  describe('HttpExecutor', function() {
    var host, object, port;
    object = void 0;
    host = sinon.spy();
    port = sinon.spy();
    before(function() {
      return object = new klass(host, port);
    });
    describe('#constructor', function() {
      it('exists method', function() {
        return object.constructor.should.be.a('function');
      });
      it('set this.host is success', function() {
        return assert.equal(object.host, host);
      });
      return it('set this.port is success', function() {
        return assert.equal(object.port, port);
      });
    });
    describe('#execute', function() {
      var callback, error, options, req, request;
      request = sinon.spy();
      callback = sinon.spy();
      error = sinon.spy();
      options = sinon.spy();
      req = {
        on: sinon.spy(),
        setTimeout: sinon.spy()
      };
      before(function() {
        sinon.stub(http, 'get', function() {
          return req;
        });
        sinon.stub(object.createConnectionCallback, 'bind', function() {
          return object.createConnectionCallback;
        });
        sinon.stub(object.setTimeoutCallback, 'bind', function() {
          return object.setTimeoutCallback;
        });
        sinon.stub(object.closeConnectionCallback, 'bind', function() {
          return object.closeConnectionCallback;
        });
        sinon.stub(object.errorConnectionCallback, 'bind', function() {
          return object.errorConnectionCallback;
        });
        sinon.stub(object.readConnectionCallback, 'bind', function() {
          return object.readConnectionCallback;
        });
        sinon.stub(object, 'options', function() {
          return options;
        });
        return object.execute(request, callback, error);
      });
      it('exists method', function() {
        return object.execute.should.be.a('function');
      });
      it('set this.request is success', function() {
        return assert.equal(object.request, request);
      });
      it('set this.callback is success', function() {
        return assert.equal(object.callback, callback);
      });
      it('set this.error is success', function() {
        return assert.equal(object.error, error);
      });
      it('called this.options', function() {
        return assert.equal(object.options.called, true);
      });
      it('called this.createConnectionCallback.bind with this', function() {
        return assert.equal(object.createConnectionCallback.bind.calledWith(object), true);
      });
      it('called http.get with options and callbacks', function() {
        return assert.equal(http.get.calledWith(options, object.createConnectionCallback, error), true);
      });
      it('called this.closeConnectionCallback.bind with this', function() {
        return assert.equal(object.closeConnectionCallback.bind.calledWith(object), true);
      });
      it('called req.on with error and callback', function() {
        return assert.equal(req.on.calledWith('close', object.closeConnectionCallback), true);
      });
      it('called this.errorConnectionCallback.bind with this', function() {
        return assert.equal(object.errorConnectionCallback.bind.calledWith(object), true);
      });
      it('called req.on with error and callback', function() {
        return assert.equal(req.on.calledWith('error', object.errorConnectionCallback), true);
      });
      it('called this.setTimeoutCallback.bind with this', function() {
        return assert.equal(object.setTimeoutCallback.bind.calledWith(object), true);
      });
      it('called req.setTimeout with timeout and callback', function() {
        return assert.equal(req.setTimeout.calledWith(5000, object.setTimeoutCallback), true);
      });
      return after(function() {
        object.options.restore();
        return object.readConnectionCallback.bind.restore();
      });
    });
    describe('#options', function() {
      return it('returns is object', function() {
        return object.options().should.be.a('object');
      });
    });
    describe('#closeConnectionCallback', function() {
      return describe('if error connect', function() {
        before(function() {
          object.res = void 0;
          object.error = sinon.spy();
          return object.closeConnectionCallback();
        });
        return it('called object.error', function() {
          return assert.ok(object.error.calledWith('Error connection'));
        });
      });
    });
    describe('#errorConnectionCallback', function() {});
    describe('#createConnectionCallback', function() {
      var readConnectionCallback, res;
      readConnectionCallback = sinon.spy();
      res = {
        on: sinon.stub()
      };
      before(function() {
        sinon.stub(object.readConnectionCallback, 'bind', function() {
          return readConnectionCallback;
        });
        return object.createConnectionCallback(res);
      });
      it('exists method', function() {
        return object.createConnectionCallback.should.be.a('function');
      });
      it('set this.res is success', function() {
        return assert.equal(object.res, res);
      });
      it('called this.readConnectionCallback.bind with object', function() {
        return assert.equal(object.readConnectionCallback.bind.calledWith(object), true);
      });
      it('called res.on with data and readConnectionCallback', function() {
        return assert.equal(res.on.calledWith('data', readConnectionCallback), true);
      });
      return after(function() {
        return object.readConnectionCallback.bind.restore();
      });
    });
    describe('#readConnectionCallback', function() {
      describe('if done is true', function() {
        var buffer, data, new_buffer, res;
        data = new Buffer(1);
        res = {
          headers: {
            'content-length': 1
          }
        };
        buffer = sinon.spy();
        new_buffer = new Buffer(1);
        before(function() {
          object.closeConnection = sinon.stub();
          object.res = res;
          object.buffer = buffer;
          object.callback = sinon.stub();
          sinon.stub(Buffer, 'concat', function() {
            return new_buffer;
          });
          return object.readConnectionCallback(data);
        });
        it('exists method', function() {
          return object.readConnectionCallback.should.be.a('function');
        });
        it('called Buffer.concat with [buffer, data]', function() {
          return assert.equal(Buffer.concat.calledWith([buffer, data]), true);
        });
        it('called this.callback with new_buffer', function() {
          return assert.equal(object.callback.calledWith(new_buffer), true);
        });
        return after(function() {
          return Buffer.concat.restore();
        });
      });
      return describe('if done is false', function() {
        var buffer, data, new_buffer, res;
        data = new Buffer(0);
        res = {
          headers: {
            'content-length': 1
          }
        };
        buffer = sinon.spy();
        new_buffer = new Buffer(0);
        before(function() {
          object.closeConnection = sinon.stub();
          object.res = res;
          object.callback = sinon.stub();
          sinon.stub(Buffer, 'concat', function() {
            return new_buffer;
          });
          return object.readConnectionCallback(data);
        });
        it('not called this.closeConnection', function() {
          return assert.equal(object.closeConnection.called, false);
        });
        it('not called this.callback with new_buffer', function() {
          return assert.equal(object.callback.called, false);
        });
        return after(function() {
          return Buffer.concat.restore();
        });
      });
    });
    return describe('#setTimeoutCallback', function() {
      before(function() {
        object.error = sinon.spy();
        return object.setTimeoutCallback();
      });
      it('exists method', function() {
        return object.setTimeoutCallback.should.be.a('function');
      });
      return it('called this.error with error', function() {
        return assert.equal(object.error.calledWith('Connection timeout!'), true);
      });
    });
  });

}).call(this);
